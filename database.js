// database.js - PostgreSQL 데이터베이스 연결 관리
const { Pool } = require('pg');
const { CONFIG, CONSTANTS } = require('./config');

class Database {
    constructor() {
        this.pool = new Pool({
            user: CONFIG.DB.USER,
            host: CONFIG.DB.HOST,
            database: CONFIG.DB.NAME,
            password: CONFIG.DB.PASSWORD,
            port: CONFIG.DB.PORT,
            max: 10,
            idleTimeoutMillis: 30000,
            connectionTimeoutMillis: 5000,
            query_timeout: CONSTANTS.DB_QUERY_TIMEOUT
        });

        this.setupEventHandlers();
    }

    setupEventHandlers() {
        this.pool.on('connect', () => {
            console.log('데이터베이스에 새 연결이 생성되었습니다.');
        });

        this.pool.on('error', (err) => {
            console.error('데이터베이스 연결 풀 오류:', err);
        });
    }

    async createTables() {
        try {
            const createTableQuery = `
                CREATE TABLE IF NOT EXISTS messages (
                    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                    nickname VARCHAR(50) NOT NULL,
                    content TEXT NOT NULL,
                    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
                    reactions JSONB DEFAULT '{}'::jsonb,
                    mentions VARCHAR(50)[] DEFAULT ARRAY[]::VARCHAR[]
                );
                CREATE INDEX IF NOT EXISTS idx_messages_created_at ON messages(created_at DESC);
                CREATE INDEX IF NOT EXISTS idx_messages_nickname ON messages(nickname);
            `;

            await this.pool.query(createTableQuery);
            console.log('데이터베이스 스키마가 성공적으로 초기화되었습니다.');
        } catch (error) {
            console.error('데이터베이스 초기화 중 오류 발생:', error);
            throw error;
        }
    }

    async saveMessage(nickname, content, mentions = []) {
        const query = `
            INSERT INTO messages (nickname, content, mentions)
            VALUES ($1, $2, $3)
            RETURNING id, created_at
        `;
        const values = [nickname, content, mentions];

        return await this.pool.query(query, values);
    }

    async getMessages(limit = CONSTANTS.DEFAULT_MESSAGE_LIMIT) {
        const query = `
            SELECT id, nickname, content, created_at AS time, reactions, mentions
            FROM messages
            ORDER BY created_at DESC
            LIMIT $1
        `;

        const result = await this.pool.query(query, [limit]);
        return result.rows.reverse();
    }

    async updateReaction(messageId, reactionType, nickname) {
        const client = await this.pool.connect();
        try {
            await client.query('BEGIN');

            const getCurrentQuery = 'SELECT reactions FROM messages WHERE id = $1 FOR UPDATE';
            const currentResult = await client.query(getCurrentQuery, [messageId]);

            if (currentResult.rows.length === 0) {
                throw new Error(`ID가 ${messageId}인 메시지를 찾을 수 없습니다.`);
            }

            let reactions = currentResult.rows[0].reactions || {};

            if (!reactions[reactionType]) {
                reactions[reactionType] = [];
            }

            const userIndex = reactions[reactionType].indexOf(nickname);
            if (userIndex === -1) {
                reactions[reactionType].push(nickname);
            } else {
                reactions[reactionType].splice(userIndex, 1);
                if (reactions[reactionType].length === 0) {
                    delete reactions[reactionType];
                }
            }

            const updateQuery = 'UPDATE messages SET reactions = $1 WHERE id = $2';
            await client.query(updateQuery, [JSON.stringify(reactions), messageId]);

            await client.query('COMMIT');
            return { success: true, reactions };
        } catch (error) {
            await client.query('ROLLBACK');
            throw error;
        } finally {
            client.release();
        }
    }

    async healthCheck() {
        try {
            await this.pool.query('SELECT 1');
            return true;
        } catch (error) {
            console.error('DB 헬스체크 실패:', error.message);
            return false;
        }
    }

    async close() {
        await this.pool.end();
        console.log('데이터베이스 연결 풀이 종료되었습니다.');
    }
}

module.exports = Database;